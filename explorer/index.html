<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CNS IB Explorer Alpha (Spike)</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #05060a;
        color: #e5e7eb;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      header {
        padding: 0.5rem 1rem;
        background: #0b1120;
        border-bottom: 1px solid #1f2937;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      header input {
        background: #020617;
        border: 1px solid #1f2937;
        color: #e5e7eb;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
      }
      header button {
        background: #4f46e5;
        border: none;
        color: white;
        padding: 0.35rem 0.75rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
      }
      header button:hover {
        background: #6366f1;
      }
      #status {
        font-size: 0.8rem;
        color: #9ca3af;
      }
      #scene-container {
        flex: 1;
        position: relative;
      }
      canvas {
        display: block;
      }
    </style>
    <!-- Three.js and OrbitControls from CDN -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <header>
      <div><strong>CNS Explorer (Spike)</strong></div>
      <label>
        Label:
        <input id="label-input" type="text" placeholder="TLS 1.3" />
      </label>
      <label>
        Hops:
        <input
          id="hops-input"
          type="number"
          min="1"
          value="1"
          style="width: 3rem"
        />
      </label>
      <button id="load-btn">Load Neighborhood</button>
      <div id="status"></div>
    </header>
    <div id="scene-container"></div>

    <script>
      const API_BASE = "http://127.0.0.1:8000"; // adjust if needed

      const container = document.getElementById("scene-container");
      const statusEl = document.getElementById("status");
      const labelInput = document.getElementById("label-input");
      const hopsInput = document.getElementById("hops-input");
      const loadBtn = document.getElementById("load-btn");

      let scene, camera, renderer, controls;
      let nodeGroup, edgeGroup;

      function initScene() {
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight - 48;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);

        camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
        camera.position.set(0, 0, 40);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.innerHTML = "";
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(10, 10, 20);
        scene.add(dir);

        nodeGroup = new THREE.Group();
        edgeGroup = new THREE.Group();
        scene.add(nodeGroup);
        scene.add(edgeGroup);

        window.addEventListener("resize", onWindowResize);
        animate();
      }

      function onWindowResize() {
        if (!renderer || !camera) return;
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight - 48;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      function layoutNodes(nodes) {
        // Simple deterministic layout: place nodes around a circle, central label near origin.
        const positions = new Map();
        const n = nodes.length;
        const radius = Math.max(10, 4 + n * 0.5);

        const central = nodes.find((n) => n.label === labelInput.value.trim());
        if (central) {
          positions.set(central.id, new THREE.Vector3(0, 0, 0));
        }

        let angleIdx = 0;
        for (const node of nodes) {
          if (positions.has(node.id)) continue;
          const angle = (angleIdx / Math.max(1, n - 1)) * Math.PI * 2;
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const z = (Math.random() - 0.5) * radius * 0.3;
          positions.set(node.id, new THREE.Vector3(x, y, z));
          angleIdx += 1;
        }
        return positions;
      }

      function renderGraph(data) {
        nodeGroup.clear();
        edgeGroup.clear();

        const nodes = data.nodes || [];
        const edges = data.edges || [];
        if (!nodes.length) {
          statusEl.textContent = "No nodes returned.";
          return;
        }

        const positions = layoutNodes(nodes);

        const centralLabel = labelInput.value.trim();
        const centralNode = nodes.find((n) => n.label === centralLabel);

        const sphereGeom = new THREE.SphereGeometry(0.6, 16, 16);
        const matCentral = new THREE.MeshStandardMaterial({ color: 0x38bdf8 });
        const matOther = new THREE.MeshStandardMaterial({ color: 0x6366f1 });

        for (const node of nodes) {
          const pos = positions.get(node.id) || new THREE.Vector3();
          const isCentral = centralNode && node.id === centralNode.id;
          const mesh = new THREE.Mesh(
            sphereGeom,
            isCentral ? matCentral : matOther
          );
          mesh.position.copy(pos);
          nodeGroup.add(mesh);
        }

        const edgeMat = new THREE.LineBasicMaterial({
          color: 0x4b5563,
          linewidth: 1,
        });
        for (const e of edges) {
          const srcPos = positions.get(e.src_id);
          const dstPos = positions.get(e.dst_id);
          if (!srcPos || !dstPos) continue;
          const geom = new THREE.BufferGeometry().setFromPoints([
            srcPos,
            dstPos,
          ]);
          const line = new THREE.Line(geom, edgeMat);
          edgeGroup.add(line);
        }

        statusEl.textContent = `Rendered ${nodes.length} nodes and ${edges.length} edges.`;
      }

      async function loadNeighborhood() {
        const label = labelInput.value.trim();
        const hops = parseInt(hopsInput.value || "1", 10) || 1;
        if (!label) {
          statusEl.textContent = "Enter a label first.";
          return;
        }
        statusEl.textContent = "Loading neighborhoodâ€¦";
        try {
          const url = `${API_BASE}/graph/neighborhood?label=${encodeURIComponent(
            label
          )}&hops=${hops}`;
          const resp = await fetch(url);
          if (!resp.ok) {
            const detail = await resp.json().catch(() => ({}));
            statusEl.textContent = `Error ${resp.status}: ${
              detail.detail || "request failed"
            }`;
            return;
          }
          const data = await resp.json();
          renderGraph(data);
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Network or server error; see console.";
        }
      }

      loadBtn.addEventListener("click", loadNeighborhood);
      labelInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          loadNeighborhood();
        }
      });

      initScene();
    </script>
  </body>
</html>
